{"ast":null,"code":"import _toConsumableArray from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { isGenerator, calcGeneratorDuration } from 'motion-dom';\nimport { invariant, millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { KeyframeResolver } from '../../render/utils/KeyframesResolver.mjs';\nimport { activeAnimations } from '../../stats/animation-count.mjs';\nimport { clamp } from '../../utils/clamp.mjs';\nimport { mix } from '../../utils/mix/index.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { inertia } from '../generators/inertia.mjs';\nimport { keyframes } from '../generators/keyframes.mjs';\nimport { spring } from '../generators/spring/index.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nvar generators = {\n  decay: inertia,\n  inertia: inertia,\n  tween: keyframes,\n  keyframes: keyframes,\n  spring: spring\n};\n\nvar percentToProgress = function percentToProgress(percent) {\n  return percent / 100;\n};\n/**\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\n * features we expose publically. Mostly the compatibility is to ensure visual identity\n * between both WAAPI and main thread animations.\n */\n\n\nvar MainThreadAnimation = /*#__PURE__*/function (_BaseAnimation) {\n  _inherits(MainThreadAnimation, _BaseAnimation);\n\n  var _super = _createSuper(MainThreadAnimation);\n\n  function MainThreadAnimation(options) {\n    var _this;\n\n    _classCallCheck(this, MainThreadAnimation);\n\n    _this = _super.call(this, options);\n    /**\n     * The time at which the animation was paused.\n     */\n\n    _this.holdTime = null;\n    /**\n     * The time at which the animation was cancelled.\n     */\n\n    _this.cancelTime = null;\n    /**\n     * The current time of the animation.\n     */\n\n    _this.currentTime = 0;\n    /**\n     * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n     */\n\n    _this.playbackSpeed = 1;\n    /**\n     * The state of the animation to apply when the animation is resolved. This\n     * allows calls to the public API to control the animation before it is resolved,\n     * without us having to resolve it first.\n     */\n\n    _this.pendingPlayState = \"running\";\n    /**\n     * The time at which the animation was started.\n     */\n\n    _this.startTime = null;\n    _this.state = \"idle\";\n    /**\n     * This method is bound to the instance to fix a pattern where\n     * animation.stop is returned as a reference from a useEffect.\n     */\n\n    _this.stop = function () {\n      _this.resolver.cancel();\n\n      _this.isStopped = true;\n      if (_this.state === \"idle\") return;\n\n      _this.teardown();\n\n      var onStop = _this.options.onStop;\n      onStop && onStop();\n    };\n\n    var _this$options = _this.options,\n        name = _this$options.name,\n        motionValue = _this$options.motionValue,\n        element = _this$options.element,\n        keyframes = _this$options.keyframes;\n    var KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\n\n    var onResolved = function onResolved(resolvedKeyframes, finalKeyframe) {\n      return _this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n    };\n\n    _this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);\n\n    _this.resolver.scheduleResolve();\n\n    return _this;\n  }\n\n  _createClass(MainThreadAnimation, [{\n    key: \"flatten\",\n    value: function flatten() {\n      _get(_getPrototypeOf(MainThreadAnimation.prototype), \"flatten\", this).call(this); // If we've already resolved the animation, re-initialise it\n\n\n      if (this._resolved) {\n        Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));\n      }\n    }\n  }, {\n    key: \"initPlayback\",\n    value: function initPlayback(keyframes$1) {\n      var _this$options2 = this.options,\n          _this$options2$type = _this$options2.type,\n          type = _this$options2$type === void 0 ? \"keyframes\" : _this$options2$type,\n          _this$options2$repeat = _this$options2.repeat,\n          repeat = _this$options2$repeat === void 0 ? 0 : _this$options2$repeat,\n          _this$options2$repeat2 = _this$options2.repeatDelay,\n          repeatDelay = _this$options2$repeat2 === void 0 ? 0 : _this$options2$repeat2,\n          repeatType = _this$options2.repeatType,\n          _this$options2$veloci = _this$options2.velocity,\n          velocity = _this$options2$veloci === void 0 ? 0 : _this$options2$veloci;\n      var generatorFactory = isGenerator(type) ? type : generators[type] || keyframes;\n      /**\n       * If our generator doesn't support mixing numbers, we need to replace keyframes with\n       * [0, 100] and then make a function that maps that to the actual keyframes.\n       *\n       * 100 is chosen instead of 1 as it works nicer with spring animations.\n       */\n\n      var mapPercentToKeyframes;\n      var mirroredGenerator;\n\n      if (process.env.NODE_ENV !== \"production\" && generatorFactory !== keyframes) {\n        invariant(keyframes$1.length <= 2, \"Only two keyframes currently supported with spring and inertia animations. Trying to animate \".concat(keyframes$1));\n      }\n\n      if (generatorFactory !== keyframes && typeof keyframes$1[0] !== \"number\") {\n        mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n        keyframes$1 = [0, 100];\n      }\n\n      var generator = generatorFactory(_objectSpread(_objectSpread({}, this.options), {}, {\n        keyframes: keyframes$1\n      }));\n      /**\n       * If we have a mirror repeat type we need to create a second generator that outputs the\n       * mirrored (not reversed) animation and later ping pong between the two generators.\n       */\n\n      if (repeatType === \"mirror\") {\n        mirroredGenerator = generatorFactory(_objectSpread(_objectSpread({}, this.options), {}, {\n          keyframes: _toConsumableArray(keyframes$1).reverse(),\n          velocity: -velocity\n        }));\n      }\n      /**\n       * If duration is undefined and we have repeat options,\n       * we need to calculate a duration from the generator.\n       *\n       * We set it to the generator itself to cache the duration.\n       * Any timeline resolver will need to have already precalculated\n       * the duration by this step.\n       */\n\n\n      if (generator.calculatedDuration === null) {\n        generator.calculatedDuration = calcGeneratorDuration(generator);\n      }\n\n      var calculatedDuration = generator.calculatedDuration;\n      var resolvedDuration = calculatedDuration + repeatDelay;\n      var totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n      return {\n        generator: generator,\n        mirroredGenerator: mirroredGenerator,\n        mapPercentToKeyframes: mapPercentToKeyframes,\n        calculatedDuration: calculatedDuration,\n        resolvedDuration: resolvedDuration,\n        totalDuration: totalDuration\n      };\n    }\n  }, {\n    key: \"onPostResolved\",\n    value: function onPostResolved() {\n      var _this$options$autopla = this.options.autoplay,\n          autoplay = _this$options$autopla === void 0 ? true : _this$options$autopla;\n      activeAnimations.mainThread++;\n      this.play();\n\n      if (this.pendingPlayState === \"paused\" || !autoplay) {\n        this.pause();\n      } else {\n        this.state = this.pendingPlayState;\n      }\n    }\n  }, {\n    key: \"tick\",\n    value: function tick(timestamp) {\n      var sample = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var resolved = this.resolved; // If the animations has failed to resolve, return the final keyframe.\n\n      if (!resolved) {\n        var _keyframes = this.options.keyframes;\n        return {\n          done: true,\n          value: _keyframes[_keyframes.length - 1]\n        };\n      }\n\n      var finalKeyframe = resolved.finalKeyframe,\n          generator = resolved.generator,\n          mirroredGenerator = resolved.mirroredGenerator,\n          mapPercentToKeyframes = resolved.mapPercentToKeyframes,\n          keyframes = resolved.keyframes,\n          calculatedDuration = resolved.calculatedDuration,\n          totalDuration = resolved.totalDuration,\n          resolvedDuration = resolved.resolvedDuration;\n      if (this.startTime === null) return generator.next(0);\n      var _this$options3 = this.options,\n          delay = _this$options3.delay,\n          repeat = _this$options3.repeat,\n          repeatType = _this$options3.repeatType,\n          repeatDelay = _this$options3.repeatDelay,\n          onUpdate = _this$options3.onUpdate;\n      /**\n       * requestAnimationFrame timestamps can come through as lower than\n       * the startTime as set by performance.now(). Here we prevent this,\n       * though in the future it could be possible to make setting startTime\n       * a pending operation that gets resolved here.\n       */\n\n      if (this.speed > 0) {\n        this.startTime = Math.min(this.startTime, timestamp);\n      } else if (this.speed < 0) {\n        this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n      } // Update currentTime\n\n\n      if (sample) {\n        this.currentTime = timestamp;\n      } else if (this.holdTime !== null) {\n        this.currentTime = this.holdTime;\n      } else {\n        // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n        // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n        // example.\n        this.currentTime = Math.round(timestamp - this.startTime) * this.speed;\n      } // Rebase on delay\n\n\n      var timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\n      var isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;\n      this.currentTime = Math.max(timeWithoutDelay, 0); // If this animation has finished, set the current time  to the total duration.\n\n      if (this.state === \"finished\" && this.holdTime === null) {\n        this.currentTime = totalDuration;\n      }\n\n      var elapsed = this.currentTime;\n      var frameGenerator = generator;\n\n      if (repeat) {\n        /**\n         * Get the current progress (0-1) of the animation. If t is >\n         * than duration we'll get values like 2.5 (midway through the\n         * third iteration)\n         */\n        var progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n        /**\n         * Get the current iteration (0 indexed). For instance the floor of\n         * 2.5 is 2.\n         */\n\n        var currentIteration = Math.floor(progress);\n        /**\n         * Get the current progress of the iteration by taking the remainder\n         * so 2.5 is 0.5 through iteration 2\n         */\n\n        var iterationProgress = progress % 1.0;\n        /**\n         * If iteration progress is 1 we count that as the end\n         * of the previous iteration.\n         */\n\n        if (!iterationProgress && progress >= 1) {\n          iterationProgress = 1;\n        }\n\n        iterationProgress === 1 && currentIteration--;\n        currentIteration = Math.min(currentIteration, repeat + 1);\n        /**\n         * Reverse progress if we're not running in \"normal\" direction\n         */\n\n        var isOddIteration = Boolean(currentIteration % 2);\n\n        if (isOddIteration) {\n          if (repeatType === \"reverse\") {\n            iterationProgress = 1 - iterationProgress;\n\n            if (repeatDelay) {\n              iterationProgress -= repeatDelay / resolvedDuration;\n            }\n          } else if (repeatType === \"mirror\") {\n            frameGenerator = mirroredGenerator;\n          }\n        }\n\n        elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n      }\n      /**\n       * If we're in negative time, set state as the initial keyframe.\n       * This prevents delay: x, duration: 0 animations from finishing\n       * instantly.\n       */\n\n\n      var state = isInDelayPhase ? {\n        done: false,\n        value: keyframes[0]\n      } : frameGenerator.next(elapsed);\n\n      if (mapPercentToKeyframes) {\n        state.value = mapPercentToKeyframes(state.value);\n      }\n\n      var done = state.done;\n\n      if (!isInDelayPhase && calculatedDuration !== null) {\n        done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;\n      }\n\n      var isAnimationFinished = this.holdTime === null && (this.state === \"finished\" || this.state === \"running\" && done);\n\n      if (isAnimationFinished && finalKeyframe !== undefined) {\n        state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\n      }\n\n      if (onUpdate) {\n        onUpdate(state.value);\n      }\n\n      if (isAnimationFinished) {\n        this.finish();\n      }\n\n      return state;\n    }\n  }, {\n    key: \"duration\",\n    get: function get() {\n      var resolved = this.resolved;\n      return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\n    }\n  }, {\n    key: \"time\",\n    get: function get() {\n      return millisecondsToSeconds(this.currentTime);\n    },\n    set: function set(newTime) {\n      newTime = secondsToMilliseconds(newTime);\n      this.currentTime = newTime;\n\n      if (this.holdTime !== null || this.speed === 0) {\n        this.holdTime = newTime;\n      } else if (this.driver) {\n        this.startTime = this.driver.now() - newTime / this.speed;\n      }\n    }\n  }, {\n    key: \"speed\",\n    get: function get() {\n      return this.playbackSpeed;\n    },\n    set: function set(newSpeed) {\n      var hasChanged = this.playbackSpeed !== newSpeed;\n      this.playbackSpeed = newSpeed;\n\n      if (hasChanged) {\n        this.time = millisecondsToSeconds(this.currentTime);\n      }\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      var _this2 = this;\n\n      if (!this.resolver.isScheduled) {\n        this.resolver.resume();\n      }\n\n      if (!this._resolved) {\n        this.pendingPlayState = \"running\";\n        return;\n      }\n\n      if (this.isStopped) return;\n      var _this$options4 = this.options,\n          _this$options4$driver = _this$options4.driver,\n          driver = _this$options4$driver === void 0 ? frameloopDriver : _this$options4$driver,\n          onPlay = _this$options4.onPlay,\n          startTime = _this$options4.startTime;\n\n      if (!this.driver) {\n        this.driver = driver(function (timestamp) {\n          return _this2.tick(timestamp);\n        });\n      }\n\n      onPlay && onPlay();\n      var now = this.driver.now();\n\n      if (this.holdTime !== null) {\n        this.startTime = now - this.holdTime;\n      } else if (!this.startTime) {\n        this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n      } else if (this.state === \"finished\") {\n        this.startTime = now;\n      }\n\n      if (this.state === \"finished\") {\n        this.updateFinishedPromise();\n      }\n\n      this.cancelTime = this.startTime;\n      this.holdTime = null;\n      /**\n       * Set playState to running only after we've used it in\n       * the previous logic.\n       */\n\n      this.state = \"running\";\n      this.driver.start();\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      var _a;\n\n      if (!this._resolved) {\n        this.pendingPlayState = \"paused\";\n        return;\n      }\n\n      this.state = \"paused\";\n      this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      if (this.state !== \"running\") {\n        this.play();\n      }\n\n      this.pendingPlayState = this.state = \"finished\";\n      this.holdTime = null;\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.teardown();\n      this.state = \"finished\";\n      var onComplete = this.options.onComplete;\n      onComplete && onComplete();\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (this.cancelTime !== null) {\n        this.tick(this.cancelTime);\n      }\n\n      this.teardown();\n      this.updateFinishedPromise();\n    }\n  }, {\n    key: \"teardown\",\n    value: function teardown() {\n      this.state = \"idle\";\n      this.stopDriver();\n      this.resolveFinishedPromise();\n      this.updateFinishedPromise();\n      this.startTime = this.cancelTime = null;\n      this.resolver.cancel();\n      activeAnimations.mainThread--;\n    }\n  }, {\n    key: \"stopDriver\",\n    value: function stopDriver() {\n      if (!this.driver) return;\n      this.driver.stop();\n      this.driver = undefined;\n    }\n  }, {\n    key: \"sample\",\n    value: function sample(time) {\n      this.startTime = 0;\n      return this.tick(time, true);\n    }\n  }]);\n\n  return MainThreadAnimation;\n}(BaseAnimation); // Legacy interface\n\n\nfunction animateValue(options) {\n  return new MainThreadAnimation(options);\n}\n\nexport { MainThreadAnimation, animateValue };","map":{"version":3,"names":["isGenerator","calcGeneratorDuration","invariant","millisecondsToSeconds","secondsToMilliseconds","KeyframeResolver","activeAnimations","clamp","mix","pipe","inertia","keyframes","spring","BaseAnimation","frameloopDriver","getFinalKeyframe","generators","decay","tween","percentToProgress","percent","MainThreadAnimation","options","holdTime","cancelTime","currentTime","playbackSpeed","pendingPlayState","startTime","state","stop","resolver","cancel","isStopped","teardown","onStop","name","motionValue","element","KeyframeResolver$1","onResolved","resolvedKeyframes","finalKeyframe","onKeyframesResolved","scheduleResolve","_resolved","Object","assign","initPlayback","keyframes$1","type","repeat","repeatDelay","repeatType","velocity","generatorFactory","mapPercentToKeyframes","mirroredGenerator","process","env","NODE_ENV","length","generator","reverse","calculatedDuration","resolvedDuration","totalDuration","autoplay","mainThread","play","pause","timestamp","sample","resolved","done","value","next","delay","onUpdate","speed","Math","min","round","timeWithoutDelay","isInDelayPhase","max","elapsed","frameGenerator","progress","currentIteration","floor","iterationProgress","isOddIteration","Boolean","isAnimationFinished","undefined","finish","newTime","driver","now","newSpeed","hasChanged","time","isScheduled","resume","onPlay","tick","calcStartTime","updateFinishedPromise","start","_a","onComplete","stopDriver","resolveFinishedPromise","animateValue"],"sources":["/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/framer-motion/dist/es/animation/animators/MainThreadAnimation.mjs"],"sourcesContent":["import { isGenerator, calcGeneratorDuration } from 'motion-dom';\nimport { invariant, millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { KeyframeResolver } from '../../render/utils/KeyframesResolver.mjs';\nimport { activeAnimations } from '../../stats/animation-count.mjs';\nimport { clamp } from '../../utils/clamp.mjs';\nimport { mix } from '../../utils/mix/index.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { inertia } from '../generators/inertia.mjs';\nimport { keyframes } from '../generators/keyframes.mjs';\nimport { spring } from '../generators/spring/index.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\nconst generators = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring,\n};\nconst percentToProgress = (percent) => percent / 100;\n/**\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\n * features we expose publically. Mostly the compatibility is to ensure visual identity\n * between both WAAPI and main thread animations.\n */\nclass MainThreadAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        /**\n         * The time at which the animation was paused.\n         */\n        this.holdTime = null;\n        /**\n         * The time at which the animation was cancelled.\n         */\n        this.cancelTime = null;\n        /**\n         * The current time of the animation.\n         */\n        this.currentTime = 0;\n        /**\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n         */\n        this.playbackSpeed = 1;\n        /**\n         * The state of the animation to apply when the animation is resolved. This\n         * allows calls to the public API to control the animation before it is resolved,\n         * without us having to resolve it first.\n         */\n        this.pendingPlayState = \"running\";\n        /**\n         * The time at which the animation was started.\n         */\n        this.startTime = null;\n        this.state = \"idle\";\n        /**\n         * This method is bound to the instance to fix a pattern where\n         * animation.stop is returned as a reference from a useEffect.\n         */\n        this.stop = () => {\n            this.resolver.cancel();\n            this.isStopped = true;\n            if (this.state === \"idle\")\n                return;\n            this.teardown();\n            const { onStop } = this.options;\n            onStop && onStop();\n        };\n        const { name, motionValue, element, keyframes } = this.options;\n        const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\n        const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n        this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);\n        this.resolver.scheduleResolve();\n    }\n    flatten() {\n        super.flatten();\n        // If we've already resolved the animation, re-initialise it\n        if (this._resolved) {\n            Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));\n        }\n    }\n    initPlayback(keyframes$1) {\n        const { type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;\n        const generatorFactory = isGenerator(type)\n            ? type\n            : generators[type] || keyframes;\n        /**\n         * If our generator doesn't support mixing numbers, we need to replace keyframes with\n         * [0, 100] and then make a function that maps that to the actual keyframes.\n         *\n         * 100 is chosen instead of 1 as it works nicer with spring animations.\n         */\n        let mapPercentToKeyframes;\n        let mirroredGenerator;\n        if (process.env.NODE_ENV !== \"production\" &&\n            generatorFactory !== keyframes) {\n            invariant(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\n        }\n        if (generatorFactory !== keyframes &&\n            typeof keyframes$1[0] !== \"number\") {\n            mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n            keyframes$1 = [0, 100];\n        }\n        const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });\n        /**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */\n        if (repeatType === \"mirror\") {\n            mirroredGenerator = generatorFactory({\n                ...this.options,\n                keyframes: [...keyframes$1].reverse(),\n                velocity: -velocity,\n            });\n        }\n        /**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */\n        if (generator.calculatedDuration === null) {\n            generator.calculatedDuration = calcGeneratorDuration(generator);\n        }\n        const { calculatedDuration } = generator;\n        const resolvedDuration = calculatedDuration + repeatDelay;\n        const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n        return {\n            generator,\n            mirroredGenerator,\n            mapPercentToKeyframes,\n            calculatedDuration,\n            resolvedDuration,\n            totalDuration,\n        };\n    }\n    onPostResolved() {\n        const { autoplay = true } = this.options;\n        activeAnimations.mainThread++;\n        this.play();\n        if (this.pendingPlayState === \"paused\" || !autoplay) {\n            this.pause();\n        }\n        else {\n            this.state = this.pendingPlayState;\n        }\n    }\n    tick(timestamp, sample = false) {\n        const { resolved } = this;\n        // If the animations has failed to resolve, return the final keyframe.\n        if (!resolved) {\n            const { keyframes } = this.options;\n            return { done: true, value: keyframes[keyframes.length - 1] };\n        }\n        const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration, } = resolved;\n        if (this.startTime === null)\n            return generator.next(0);\n        const { delay, repeat, repeatType, repeatDelay, onUpdate } = this.options;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (this.speed > 0) {\n            this.startTime = Math.min(this.startTime, timestamp);\n        }\n        else if (this.speed < 0) {\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n        }\n        // Update currentTime\n        if (sample) {\n            this.currentTime = timestamp;\n        }\n        else if (this.holdTime !== null) {\n            this.currentTime = this.holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            this.currentTime =\n                Math.round(timestamp - this.startTime) * this.speed;\n        }\n        // Rebase on delay\n        const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\n        const isInDelayPhase = this.speed >= 0\n            ? timeWithoutDelay < 0\n            : timeWithoutDelay > totalDuration;\n        this.currentTime = Math.max(timeWithoutDelay, 0);\n        // If this animation has finished, set the current time  to the total duration.\n        if (this.state === \"finished\" && this.holdTime === null) {\n            this.currentTime = totalDuration;\n        }\n        let elapsed = this.currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const isOddIteration = Boolean(currentIteration % 2);\n            if (isOddIteration) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes[0] }\n            : frameGenerator.next(elapsed);\n        if (mapPercentToKeyframes) {\n            state.value = mapPercentToKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done =\n                this.speed >= 0\n                    ? this.currentTime >= totalDuration\n                    : this.currentTime <= 0;\n        }\n        const isAnimationFinished = this.holdTime === null &&\n            (this.state === \"finished\" || (this.state === \"running\" && done));\n        if (isAnimationFinished && finalKeyframe !== undefined) {\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\n        }\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            this.finish();\n        }\n        return state;\n    }\n    get duration() {\n        const { resolved } = this;\n        return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\n    }\n    get time() {\n        return millisecondsToSeconds(this.currentTime);\n    }\n    set time(newTime) {\n        newTime = secondsToMilliseconds(newTime);\n        this.currentTime = newTime;\n        if (this.holdTime !== null || this.speed === 0) {\n            this.holdTime = newTime;\n        }\n        else if (this.driver) {\n            this.startTime = this.driver.now() - newTime / this.speed;\n        }\n    }\n    get speed() {\n        return this.playbackSpeed;\n    }\n    set speed(newSpeed) {\n        const hasChanged = this.playbackSpeed !== newSpeed;\n        this.playbackSpeed = newSpeed;\n        if (hasChanged) {\n            this.time = millisecondsToSeconds(this.currentTime);\n        }\n    }\n    play() {\n        if (!this.resolver.isScheduled) {\n            this.resolver.resume();\n        }\n        if (!this._resolved) {\n            this.pendingPlayState = \"running\";\n            return;\n        }\n        if (this.isStopped)\n            return;\n        const { driver = frameloopDriver, onPlay, startTime } = this.options;\n        if (!this.driver) {\n            this.driver = driver((timestamp) => this.tick(timestamp));\n        }\n        onPlay && onPlay();\n        const now = this.driver.now();\n        if (this.holdTime !== null) {\n            this.startTime = now - this.holdTime;\n        }\n        else if (!this.startTime) {\n            this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n        }\n        else if (this.state === \"finished\") {\n            this.startTime = now;\n        }\n        if (this.state === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        this.cancelTime = this.startTime;\n        this.holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        this.state = \"running\";\n        this.driver.start();\n    }\n    pause() {\n        var _a;\n        if (!this._resolved) {\n            this.pendingPlayState = \"paused\";\n            return;\n        }\n        this.state = \"paused\";\n        this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\n    }\n    complete() {\n        if (this.state !== \"running\") {\n            this.play();\n        }\n        this.pendingPlayState = this.state = \"finished\";\n        this.holdTime = null;\n    }\n    finish() {\n        this.teardown();\n        this.state = \"finished\";\n        const { onComplete } = this.options;\n        onComplete && onComplete();\n    }\n    cancel() {\n        if (this.cancelTime !== null) {\n            this.tick(this.cancelTime);\n        }\n        this.teardown();\n        this.updateFinishedPromise();\n    }\n    teardown() {\n        this.state = \"idle\";\n        this.stopDriver();\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        this.startTime = this.cancelTime = null;\n        this.resolver.cancel();\n        activeAnimations.mainThread--;\n    }\n    stopDriver() {\n        if (!this.driver)\n            return;\n        this.driver.stop();\n        this.driver = undefined;\n    }\n    sample(time) {\n        this.startTime = 0;\n        return this.tick(time, true);\n    }\n}\n// Legacy interface\nfunction animateValue(options) {\n    return new MainThreadAnimation(options);\n}\n\nexport { MainThreadAnimation, animateValue };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}