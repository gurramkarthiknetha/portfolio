{"ast":null,"code":"import _toConsumableArray from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { clamp } from '../../../../utils/clamp.mjs';\nimport { interpolate } from '../../../../utils/interpolate.mjs';\nimport { defaultOffset } from '../../../../utils/offsets/default.mjs';\nimport { calcInset } from './inset.mjs';\nimport { resolveOffset } from './offset.mjs';\nimport { ScrollOffset } from './presets.mjs';\nvar point = {\n  x: 0,\n  y: 0\n};\n\nfunction getTargetSize(target) {\n  return \"getBBox\" in target && target.tagName !== \"svg\" ? target.getBBox() : {\n    width: target.clientWidth,\n    height: target.clientHeight\n  };\n}\n\nfunction resolveOffsets(container, info, options) {\n  var _options$offset = options.offset,\n      offsetDefinition = _options$offset === void 0 ? ScrollOffset.All : _options$offset;\n  var _options$target = options.target,\n      target = _options$target === void 0 ? container : _options$target,\n      _options$axis = options.axis,\n      axis = _options$axis === void 0 ? \"y\" : _options$axis;\n  var lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n  var inset = target !== container ? calcInset(target, container) : point;\n  /**\n   * Measure the target and container. If they're the same thing then we\n   * use the container's scrollWidth/Height as the target, from there\n   * all other calculations can remain the same.\n   */\n\n  var targetSize = target === container ? {\n    width: container.scrollWidth,\n    height: container.scrollHeight\n  } : getTargetSize(target);\n  var containerSize = {\n    width: container.clientWidth,\n    height: container.clientHeight\n  };\n  /**\n   * Reset the length of the resolved offset array rather than creating a new one.\n   * TODO: More reusable data structures for targetSize/containerSize would also be good.\n   */\n\n  info[axis].offset.length = 0;\n  /**\n   * Populate the offset array by resolving the user's offset definition into\n   * a list of pixel scroll offets.\n   */\n\n  var hasChanged = !info[axis].interpolate;\n  var numOffsets = offsetDefinition.length;\n\n  for (var i = 0; i < numOffsets; i++) {\n    var offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n\n    if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n      hasChanged = true;\n    }\n\n    info[axis].offset[i] = offset;\n  }\n  /**\n   * If the pixel scroll offsets have changed, create a new interpolator function\n   * to map scroll value into a progress.\n   */\n\n\n  if (hasChanged) {\n    info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition), {\n      clamp: false\n    });\n    info[axis].interpolatorOffsets = _toConsumableArray(info[axis].offset);\n  }\n\n  info[axis].progress = clamp(0, 1, info[axis].interpolate(info[axis].current));\n}\n\nexport { resolveOffsets };","map":{"version":3,"names":["clamp","interpolate","defaultOffset","calcInset","resolveOffset","ScrollOffset","point","x","y","getTargetSize","target","tagName","getBBox","width","clientWidth","height","clientHeight","resolveOffsets","container","info","options","offset","offsetDefinition","All","axis","lengthLabel","inset","targetSize","scrollWidth","scrollHeight","containerSize","length","hasChanged","numOffsets","i","interpolatorOffsets","progress","current"],"sources":["/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs"],"sourcesContent":["import { clamp } from '../../../../utils/clamp.mjs';\nimport { interpolate } from '../../../../utils/interpolate.mjs';\nimport { defaultOffset } from '../../../../utils/offsets/default.mjs';\nimport { calcInset } from './inset.mjs';\nimport { resolveOffset } from './offset.mjs';\nimport { ScrollOffset } from './presets.mjs';\n\nconst point = { x: 0, y: 0 };\nfunction getTargetSize(target) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? target.getBBox()\n        : { width: target.clientWidth, height: target.clientHeight };\n}\nfunction resolveOffsets(container, info, options) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : getTargetSize(target);\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition), { clamp: false });\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = clamp(0, 1, info[axis].interpolate(info[axis].current));\n}\n\nexport { resolveOffsets };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}