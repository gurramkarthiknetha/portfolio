{"ast":null,"code":"import _objectWithoutProperties from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _classCallCheck from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _objectSpread from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _excluded = [\"onComplete\", \"onUpdate\", \"motionValue\", \"element\"],\n    _excluded2 = [\"motionValue\", \"onUpdate\", \"onComplete\", \"element\"];\nimport { supportsLinearEasing, attachTimeline as _attachTimeline, isGenerator, isWaapiSupportedEasing } from 'motion-dom';\nimport { millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { anticipate } from '../../easing/anticipate.mjs';\nimport { backInOut } from '../../easing/back.mjs';\nimport { circInOut } from '../../easing/circ.mjs';\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { acceleratedValues } from './utils/accelerated-values.mjs';\nimport { startWaapiAnimation } from './waapi/index.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nimport { supportsWaapi } from './waapi/utils/supports-waapi.mjs';\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\n\nvar sampleDelta = 10; //ms\n\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\n\nvar maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\n\nfunction requiresPregeneratedKeyframes(options) {\n  return isGenerator(options.type) || options.type === \"spring\" || !isWaapiSupportedEasing(options.ease);\n}\n\nfunction pregenerateKeyframes(keyframes, options) {\n  /**\n   * Create a main-thread animation to pregenerate keyframes.\n   * We sample this at regular intervals to generate keyframes that we then\n   * linearly interpolate between.\n   */\n  var sampleAnimation = new MainThreadAnimation(_objectSpread(_objectSpread({}, options), {}, {\n    keyframes: keyframes,\n    repeat: 0,\n    delay: 0,\n    isGenerator: true\n  }));\n  var state = {\n    done: false,\n    value: keyframes[0]\n  };\n  var pregeneratedKeyframes = [];\n  /**\n   * Bail after 20 seconds of pre-generated keyframes as it's likely\n   * we're heading for an infinite loop.\n   */\n\n  var t = 0;\n\n  while (!state.done && t < maxDuration) {\n    state = sampleAnimation.sample(t);\n    pregeneratedKeyframes.push(state.value);\n    t += sampleDelta;\n  }\n\n  return {\n    times: undefined,\n    keyframes: pregeneratedKeyframes,\n    duration: t - sampleDelta,\n    ease: \"linear\"\n  };\n}\n\nvar unsupportedEasingFunctions = {\n  anticipate: anticipate,\n  backInOut: backInOut,\n  circInOut: circInOut\n};\n\nfunction isUnsupportedEase(key) {\n  return key in unsupportedEasingFunctions;\n}\n\nvar AcceleratedAnimation = /*#__PURE__*/function (_BaseAnimation) {\n  _inherits(AcceleratedAnimation, _BaseAnimation);\n\n  var _super = _createSuper(AcceleratedAnimation);\n\n  function AcceleratedAnimation(options) {\n    var _this;\n\n    _classCallCheck(this, AcceleratedAnimation);\n\n    _this = _super.call(this, options);\n    var _this$options = _this.options,\n        name = _this$options.name,\n        motionValue = _this$options.motionValue,\n        element = _this$options.element,\n        keyframes = _this$options.keyframes;\n    _this.resolver = new DOMKeyframesResolver(keyframes, function (resolvedKeyframes, finalKeyframe) {\n      return _this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n    }, name, motionValue, element);\n\n    _this.resolver.scheduleResolve();\n\n    return _this;\n  }\n\n  _createClass(AcceleratedAnimation, [{\n    key: \"initPlayback\",\n    value: function initPlayback(keyframes, finalKeyframe) {\n      var _this2 = this;\n\n      var _this$options2 = this.options,\n          _this$options2$durati = _this$options2.duration,\n          duration = _this$options2$durati === void 0 ? 300 : _this$options2$durati,\n          times = _this$options2.times,\n          ease = _this$options2.ease,\n          type = _this$options2.type,\n          motionValue = _this$options2.motionValue,\n          name = _this$options2.name,\n          startTime = _this$options2.startTime;\n      /**\n       * If element has since been unmounted, return false to indicate\n       * the animation failed to initialised.\n       */\n\n      if (!motionValue.owner || !motionValue.owner.current) {\n        return false;\n      }\n      /**\n       * If the user has provided an easing function name that isn't supported\n       * by WAAPI (like \"anticipate\"), we need to provide the corressponding\n       * function. This will later get converted to a linear() easing function.\n       */\n\n\n      if (typeof ease === \"string\" && supportsLinearEasing() && isUnsupportedEase(ease)) {\n        ease = unsupportedEasingFunctions[ease];\n      }\n      /**\n       * If this animation needs pre-generated keyframes then generate.\n       */\n\n\n      if (requiresPregeneratedKeyframes(this.options)) {\n        var _this$options3 = this.options,\n            onComplete = _this$options3.onComplete,\n            onUpdate = _this$options3.onUpdate,\n            _motionValue = _this$options3.motionValue,\n            element = _this$options3.element,\n            options = _objectWithoutProperties(_this$options3, _excluded);\n\n        var pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n        keyframes = pregeneratedAnimation.keyframes; // If this is a very short animation, ensure we have\n        // at least two keyframes to animate between as older browsers\n        // can't animate between a single keyframe.\n\n        if (keyframes.length === 1) {\n          keyframes[1] = keyframes[0];\n        }\n\n        duration = pregeneratedAnimation.duration;\n        times = pregeneratedAnimation.times;\n        ease = pregeneratedAnimation.ease;\n        type = \"keyframes\";\n      }\n\n      var animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, _objectSpread(_objectSpread({}, this.options), {}, {\n        duration: duration,\n        times: times,\n        ease: ease\n      })); // Override the browser calculated startTime with one synchronised to other JS\n      // and WAAPI animations starting this event loop.\n\n      animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n\n      if (this.pendingTimeline) {\n        _attachTimeline(animation, this.pendingTimeline);\n\n        this.pendingTimeline = undefined;\n      } else {\n        /**\n         * Prefer the `onfinish` prop as it's more widely supported than\n         * the `finished` promise.\n         *\n         * Here, we synchronously set the provided MotionValue to the end\n         * keyframe. If we didn't, when the WAAPI animation is finished it would\n         * be removed from the element which would then revert to its old styles.\n         */\n        animation.onfinish = function () {\n          var onComplete = _this2.options.onComplete;\n          motionValue.set(getFinalKeyframe(keyframes, _this2.options, finalKeyframe));\n          onComplete && onComplete();\n\n          _this2.cancel();\n\n          _this2.resolveFinishedPromise();\n        };\n      }\n\n      return {\n        animation: animation,\n        duration: duration,\n        times: times,\n        type: type,\n        ease: ease,\n        keyframes: keyframes\n      };\n    }\n  }, {\n    key: \"duration\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return 0;\n      var duration = resolved.duration;\n      return millisecondsToSeconds(duration);\n    }\n  }, {\n    key: \"time\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return 0;\n      var animation = resolved.animation;\n      return millisecondsToSeconds(animation.currentTime || 0);\n    },\n    set: function set(newTime) {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n      animation.currentTime = secondsToMilliseconds(newTime);\n    }\n  }, {\n    key: \"speed\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return 1;\n      var animation = resolved.animation;\n      return animation.playbackRate;\n    },\n    set: function set(newSpeed) {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n      animation.playbackRate = newSpeed;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return \"idle\";\n      var animation = resolved.animation;\n      return animation.playState;\n    }\n  }, {\n    key: \"startTime\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return null;\n      var animation = resolved.animation; // Coerce to number as TypeScript incorrectly types this\n      // as CSSNumberish\n\n      return animation.startTime;\n    }\n    /**\n     * Replace the default DocumentTimeline with another AnimationTimeline.\n     * Currently used for scroll animations.\n     */\n\n  }, {\n    key: \"attachTimeline\",\n    value: function attachTimeline(timeline) {\n      if (!this._resolved) {\n        this.pendingTimeline = timeline;\n      } else {\n        var resolved = this.resolved;\n        if (!resolved) return noop;\n        var animation = resolved.animation;\n\n        _attachTimeline(animation, timeline);\n      }\n\n      return noop;\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      if (this.isStopped) return;\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n\n      if (animation.playState === \"finished\") {\n        this.updateFinishedPromise();\n      }\n\n      animation.play();\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n      animation.pause();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.resolver.cancel();\n      this.isStopped = true;\n      if (this.state === \"idle\") return;\n      this.resolveFinishedPromise();\n      this.updateFinishedPromise();\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation,\n          keyframes = resolved.keyframes,\n          duration = resolved.duration,\n          type = resolved.type,\n          ease = resolved.ease,\n          times = resolved.times;\n\n      if (animation.playState === \"idle\" || animation.playState === \"finished\") {\n        return;\n      }\n      /**\n       * WAAPI doesn't natively have any interruption capabilities.\n       *\n       * Rather than read commited styles back out of the DOM, we can\n       * create a renderless JS animation and sample it twice to calculate\n       * its current value, \"previous\" value, and therefore allow\n       * Motion to calculate velocity for any subsequent animation.\n       */\n\n\n      if (this.time) {\n        var _this$options4 = this.options,\n            motionValue = _this$options4.motionValue,\n            onUpdate = _this$options4.onUpdate,\n            onComplete = _this$options4.onComplete,\n            element = _this$options4.element,\n            options = _objectWithoutProperties(_this$options4, _excluded2);\n\n        var sampleAnimation = new MainThreadAnimation(_objectSpread(_objectSpread({}, options), {}, {\n          keyframes: keyframes,\n          duration: duration,\n          type: type,\n          ease: ease,\n          times: times,\n          isGenerator: true\n        }));\n        var sampleTime = secondsToMilliseconds(this.time);\n        motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n      }\n\n      var onStop = this.options.onStop;\n      onStop && onStop();\n      this.cancel();\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      resolved.animation.finish();\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      resolved.animation.cancel();\n    }\n  }], [{\n    key: \"supports\",\n    value: function supports(options) {\n      var motionValue = options.motionValue,\n          name = options.name,\n          repeatDelay = options.repeatDelay,\n          repeatType = options.repeatType,\n          damping = options.damping,\n          type = options.type;\n\n      if (!motionValue || !motionValue.owner || !(motionValue.owner.current instanceof HTMLElement)) {\n        return false;\n      }\n\n      var _motionValue$owner$ge = motionValue.owner.getProps(),\n          onUpdate = _motionValue$owner$ge.onUpdate,\n          transformTemplate = _motionValue$owner$ge.transformTemplate;\n\n      return supportsWaapi() && name && acceleratedValues.has(name) &&\n      /**\n       * If we're outputting values to onUpdate then we can't use WAAPI as there's\n       * no way to read the value from WAAPI every frame.\n       */\n      !onUpdate && !transformTemplate && !repeatDelay && repeatType !== \"mirror\" && damping !== 0 && type !== \"inertia\";\n    }\n  }]);\n\n  return AcceleratedAnimation;\n}(BaseAnimation);\n\nexport { AcceleratedAnimation };","map":{"version":3,"names":["supportsLinearEasing","attachTimeline","isGenerator","isWaapiSupportedEasing","millisecondsToSeconds","secondsToMilliseconds","noop","anticipate","backInOut","circInOut","DOMKeyframesResolver","BaseAnimation","MainThreadAnimation","acceleratedValues","startWaapiAnimation","getFinalKeyframe","supportsWaapi","sampleDelta","maxDuration","requiresPregeneratedKeyframes","options","type","ease","pregenerateKeyframes","keyframes","sampleAnimation","repeat","delay","state","done","value","pregeneratedKeyframes","t","sample","push","times","undefined","duration","unsupportedEasingFunctions","isUnsupportedEase","key","AcceleratedAnimation","name","motionValue","element","resolver","resolvedKeyframes","finalKeyframe","onKeyframesResolved","scheduleResolve","startTime","owner","current","onComplete","onUpdate","pregeneratedAnimation","length","animation","calcStartTime","pendingTimeline","onfinish","set","cancel","resolveFinishedPromise","resolved","currentTime","newTime","playbackRate","newSpeed","playState","timeline","_resolved","isStopped","updateFinishedPromise","play","pause","time","sampleTime","setWithVelocity","onStop","finish","repeatDelay","repeatType","damping","HTMLElement","getProps","transformTemplate","has"],"sources":["/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs"],"sourcesContent":["import { supportsLinearEasing, attachTimeline, isGenerator, isWaapiSupportedEasing } from 'motion-dom';\nimport { millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { anticipate } from '../../easing/anticipate.mjs';\nimport { backInOut } from '../../easing/back.mjs';\nimport { circInOut } from '../../easing/circ.mjs';\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { acceleratedValues } from './utils/accelerated-values.mjs';\nimport { startWaapiAnimation } from './waapi/index.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nimport { supportsWaapi } from './waapi/utils/supports-waapi.mjs';\n\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\nfunction requiresPregeneratedKeyframes(options) {\n    return (isGenerator(options.type) ||\n        options.type === \"spring\" ||\n        !isWaapiSupportedEasing(options.ease));\n}\nfunction pregenerateKeyframes(keyframes, options) {\n    /**\n     * Create a main-thread animation to pregenerate keyframes.\n     * We sample this at regular intervals to generate keyframes that we then\n     * linearly interpolate between.\n     */\n    const sampleAnimation = new MainThreadAnimation({\n        ...options,\n        keyframes,\n        repeat: 0,\n        delay: 0,\n        isGenerator: true,\n    });\n    let state = { done: false, value: keyframes[0] };\n    const pregeneratedKeyframes = [];\n    /**\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\n     * we're heading for an infinite loop.\n     */\n    let t = 0;\n    while (!state.done && t < maxDuration) {\n        state = sampleAnimation.sample(t);\n        pregeneratedKeyframes.push(state.value);\n        t += sampleDelta;\n    }\n    return {\n        times: undefined,\n        keyframes: pregeneratedKeyframes,\n        duration: t - sampleDelta,\n        ease: \"linear\",\n    };\n}\nconst unsupportedEasingFunctions = {\n    anticipate,\n    backInOut,\n    circInOut,\n};\nfunction isUnsupportedEase(key) {\n    return key in unsupportedEasingFunctions;\n}\nclass AcceleratedAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        const { name, motionValue, element, keyframes } = this.options;\n        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\n        this.resolver.scheduleResolve();\n    }\n    initPlayback(keyframes, finalKeyframe) {\n        let { duration = 300, times, ease, type, motionValue, name, startTime, } = this.options;\n        /**\n         * If element has since been unmounted, return false to indicate\n         * the animation failed to initialised.\n         */\n        if (!motionValue.owner || !motionValue.owner.current) {\n            return false;\n        }\n        /**\n         * If the user has provided an easing function name that isn't supported\n         * by WAAPI (like \"anticipate\"), we need to provide the corressponding\n         * function. This will later get converted to a linear() easing function.\n         */\n        if (typeof ease === \"string\" &&\n            supportsLinearEasing() &&\n            isUnsupportedEase(ease)) {\n            ease = unsupportedEasingFunctions[ease];\n        }\n        /**\n         * If this animation needs pre-generated keyframes then generate.\n         */\n        if (requiresPregeneratedKeyframes(this.options)) {\n            const { onComplete, onUpdate, motionValue, element, ...options } = this.options;\n            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n            keyframes = pregeneratedAnimation.keyframes;\n            // If this is a very short animation, ensure we have\n            // at least two keyframes to animate between as older browsers\n            // can't animate between a single keyframe.\n            if (keyframes.length === 1) {\n                keyframes[1] = keyframes[0];\n            }\n            duration = pregeneratedAnimation.duration;\n            times = pregeneratedAnimation.times;\n            ease = pregeneratedAnimation.ease;\n            type = \"keyframes\";\n        }\n        const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, { ...this.options, duration, times, ease });\n        // Override the browser calculated startTime with one synchronised to other JS\n        // and WAAPI animations starting this event loop.\n        animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n        if (this.pendingTimeline) {\n            attachTimeline(animation, this.pendingTimeline);\n            this.pendingTimeline = undefined;\n        }\n        else {\n            /**\n             * Prefer the `onfinish` prop as it's more widely supported than\n             * the `finished` promise.\n             *\n             * Here, we synchronously set the provided MotionValue to the end\n             * keyframe. If we didn't, when the WAAPI animation is finished it would\n             * be removed from the element which would then revert to its old styles.\n             */\n            animation.onfinish = () => {\n                const { onComplete } = this.options;\n                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete && onComplete();\n                this.cancel();\n                this.resolveFinishedPromise();\n            };\n        }\n        return {\n            animation,\n            duration,\n            times,\n            type,\n            ease,\n            keyframes: keyframes,\n        };\n    }\n    get duration() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { duration } = resolved;\n        return millisecondsToSeconds(duration);\n    }\n    get time() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { animation } = resolved;\n        return millisecondsToSeconds(animation.currentTime || 0);\n    }\n    set time(newTime) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.currentTime = secondsToMilliseconds(newTime);\n    }\n    get speed() {\n        const { resolved } = this;\n        if (!resolved)\n            return 1;\n        const { animation } = resolved;\n        return animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.playbackRate = newSpeed;\n    }\n    get state() {\n        const { resolved } = this;\n        if (!resolved)\n            return \"idle\";\n        const { animation } = resolved;\n        return animation.playState;\n    }\n    get startTime() {\n        const { resolved } = this;\n        if (!resolved)\n            return null;\n        const { animation } = resolved;\n        // Coerce to number as TypeScript incorrectly types this\n        // as CSSNumberish\n        return animation.startTime;\n    }\n    /**\n     * Replace the default DocumentTimeline with another AnimationTimeline.\n     * Currently used for scroll animations.\n     */\n    attachTimeline(timeline) {\n        if (!this._resolved) {\n            this.pendingTimeline = timeline;\n        }\n        else {\n            const { resolved } = this;\n            if (!resolved)\n                return noop;\n            const { animation } = resolved;\n            attachTimeline(animation, timeline);\n        }\n        return noop;\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        if (animation.playState === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        animation.play();\n    }\n    pause() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.pause();\n    }\n    stop() {\n        this.resolver.cancel();\n        this.isStopped = true;\n        if (this.state === \"idle\")\n            return;\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation, keyframes, duration, type, ease, times } = resolved;\n        if (animation.playState === \"idle\" ||\n            animation.playState === \"finished\") {\n            return;\n        }\n        /**\n         * WAAPI doesn't natively have any interruption capabilities.\n         *\n         * Rather than read commited styles back out of the DOM, we can\n         * create a renderless JS animation and sample it twice to calculate\n         * its current value, \"previous\" value, and therefore allow\n         * Motion to calculate velocity for any subsequent animation.\n         */\n        if (this.time) {\n            const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\n            const sampleAnimation = new MainThreadAnimation({\n                ...options,\n                keyframes,\n                duration,\n                type,\n                ease,\n                times,\n                isGenerator: true,\n            });\n            const sampleTime = secondsToMilliseconds(this.time);\n            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n        }\n        const { onStop } = this.options;\n        onStop && onStop();\n        this.cancel();\n    }\n    complete() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.finish();\n    }\n    cancel() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.cancel();\n    }\n    static supports(options) {\n        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\n        if (!motionValue ||\n            !motionValue.owner ||\n            !(motionValue.owner.current instanceof HTMLElement)) {\n            return false;\n        }\n        const { onUpdate, transformTemplate } = motionValue.owner.getProps();\n        return (supportsWaapi() &&\n            name &&\n            acceleratedValues.has(name) &&\n            /**\n             * If we're outputting values to onUpdate then we can't use WAAPI as there's\n             * no way to read the value from WAAPI every frame.\n             */\n            !onUpdate &&\n            !transformTemplate &&\n            !repeatDelay &&\n            repeatType !== \"mirror\" &&\n            damping !== 0 &&\n            type !== \"inertia\");\n    }\n}\n\nexport { AcceleratedAnimation };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}