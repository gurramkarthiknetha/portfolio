{"ast":null,"code":"import { statsBuffer } from '../stats/buffer.mjs';\n\nfunction createRenderStep(runNextFrame, stepName) {\n  /**\n   * We create and reuse two queues, one to queue jobs for the current frame\n   * and one for the next. We reuse to avoid triggering GC after x frames.\n   */\n  var thisFrame = new Set();\n  var nextFrame = new Set();\n  /**\n   * Track whether we're currently processing jobs in this step. This way\n   * we can decide whether to schedule new jobs for this frame or next.\n   */\n\n  var isProcessing = false;\n  var flushNextFrame = false;\n  /**\n   * A set of processes which were marked keepAlive when scheduled.\n   */\n\n  var toKeepAlive = new WeakSet();\n  var latestFrameData = {\n    delta: 0.0,\n    timestamp: 0.0,\n    isProcessing: false\n  };\n  var numCalls = 0;\n\n  function triggerCallback(callback) {\n    if (toKeepAlive.has(callback)) {\n      step.schedule(callback);\n      runNextFrame();\n    }\n\n    numCalls++;\n    callback(latestFrameData);\n  }\n\n  var step = {\n    /**\n     * Schedule a process to run on the next frame.\n     */\n    schedule: function schedule(callback) {\n      var keepAlive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var addToCurrentFrame = immediate && isProcessing;\n      var queue = addToCurrentFrame ? thisFrame : nextFrame;\n      if (keepAlive) toKeepAlive.add(callback);\n      if (!queue.has(callback)) queue.add(callback);\n      return callback;\n    },\n\n    /**\n     * Cancel the provided callback from running on the next frame.\n     */\n    cancel: function cancel(callback) {\n      nextFrame.delete(callback);\n      toKeepAlive.delete(callback);\n    },\n\n    /**\n     * Execute all schedule callbacks.\n     */\n    process: function process(frameData) {\n      latestFrameData = frameData;\n      /**\n       * If we're already processing we've probably been triggered by a flushSync\n       * inside an existing process. Instead of executing, mark flushNextFrame\n       * as true and ensure we flush the following frame at the end of this one.\n       */\n\n      if (isProcessing) {\n        flushNextFrame = true;\n        return;\n      }\n\n      isProcessing = true;\n      var _ref = [nextFrame, thisFrame];\n      thisFrame = _ref[0];\n      nextFrame = _ref[1];\n      // Execute this frame\n      thisFrame.forEach(triggerCallback);\n      /**\n       * If we're recording stats then\n       */\n\n      if (stepName && statsBuffer.value) {\n        statsBuffer.value.frameloop[stepName].push(numCalls);\n      }\n\n      numCalls = 0; // Clear the frame so no callbacks remain. This is to avoid\n      // memory leaks should this render step not run for a while.\n\n      thisFrame.clear();\n      isProcessing = false;\n\n      if (flushNextFrame) {\n        flushNextFrame = false;\n        step.process(frameData);\n      }\n    }\n  };\n  return step;\n}\n\nexport { createRenderStep };","map":{"version":3,"names":["statsBuffer","createRenderStep","runNextFrame","stepName","thisFrame","Set","nextFrame","isProcessing","flushNextFrame","toKeepAlive","WeakSet","latestFrameData","delta","timestamp","numCalls","triggerCallback","callback","has","step","schedule","keepAlive","immediate","addToCurrentFrame","queue","add","cancel","delete","process","frameData","forEach","value","frameloop","push","clear"],"sources":["/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/framer-motion/dist/es/frameloop/render-step.mjs"],"sourcesContent":["import { statsBuffer } from '../stats/buffer.mjs';\n\nfunction createRenderStep(runNextFrame, stepName) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Set();\n    let nextFrame = new Set();\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    let latestFrameData = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    let numCalls = 0;\n    function triggerCallback(callback) {\n        if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n        }\n        numCalls++;\n        callback(latestFrameData);\n    }\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (!queue.has(callback))\n                queue.add(callback);\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            nextFrame.delete(callback);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            latestFrameData = frameData;\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\n            // Execute this frame\n            thisFrame.forEach(triggerCallback);\n            /**\n             * If we're recording stats then\n             */\n            if (stepName && statsBuffer.value) {\n                statsBuffer.value.frameloop[stepName].push(numCalls);\n            }\n            numCalls = 0;\n            // Clear the frame so no callbacks remain. This is to avoid\n            // memory leaks should this render step not run for a while.\n            thisFrame.clear();\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nexport { createRenderStep };\n"],"mappings":"AAAA,SAASA,WAAT,QAA4B,qBAA5B;;AAEA,SAASC,gBAAT,CAA0BC,YAA1B,EAAwCC,QAAxC,EAAkD;EAC9C;AACJ;AACA;AACA;EACI,IAAIC,SAAS,GAAG,IAAIC,GAAJ,EAAhB;EACA,IAAIC,SAAS,GAAG,IAAID,GAAJ,EAAhB;EACA;AACJ;AACA;AACA;;EACI,IAAIE,YAAY,GAAG,KAAnB;EACA,IAAIC,cAAc,GAAG,KAArB;EACA;AACJ;AACA;;EACI,IAAMC,WAAW,GAAG,IAAIC,OAAJ,EAApB;EACA,IAAIC,eAAe,GAAG;IAClBC,KAAK,EAAE,GADW;IAElBC,SAAS,EAAE,GAFO;IAGlBN,YAAY,EAAE;EAHI,CAAtB;EAKA,IAAIO,QAAQ,GAAG,CAAf;;EACA,SAASC,eAAT,CAAyBC,QAAzB,EAAmC;IAC/B,IAAIP,WAAW,CAACQ,GAAZ,CAAgBD,QAAhB,CAAJ,EAA+B;MAC3BE,IAAI,CAACC,QAAL,CAAcH,QAAd;MACAd,YAAY;IACf;;IACDY,QAAQ;IACRE,QAAQ,CAACL,eAAD,CAAR;EACH;;EACD,IAAMO,IAAI,GAAG;IACT;AACR;AACA;IACQC,QAAQ,EAAE,kBAACH,QAAD,EAAoD;MAAA,IAAzCI,SAAyC,uEAA7B,KAA6B;MAAA,IAAtBC,SAAsB,uEAAV,KAAU;MAC1D,IAAMC,iBAAiB,GAAGD,SAAS,IAAId,YAAvC;MACA,IAAMgB,KAAK,GAAGD,iBAAiB,GAAGlB,SAAH,GAAeE,SAA9C;MACA,IAAIc,SAAJ,EACIX,WAAW,CAACe,GAAZ,CAAgBR,QAAhB;MACJ,IAAI,CAACO,KAAK,CAACN,GAAN,CAAUD,QAAV,CAAL,EACIO,KAAK,CAACC,GAAN,CAAUR,QAAV;MACJ,OAAOA,QAAP;IACH,CAZQ;;IAaT;AACR;AACA;IACQS,MAAM,EAAE,gBAACT,QAAD,EAAc;MAClBV,SAAS,CAACoB,MAAV,CAAiBV,QAAjB;MACAP,WAAW,CAACiB,MAAZ,CAAmBV,QAAnB;IACH,CAnBQ;;IAoBT;AACR;AACA;IACQW,OAAO,EAAE,iBAACC,SAAD,EAAe;MACpBjB,eAAe,GAAGiB,SAAlB;MACA;AACZ;AACA;AACA;AACA;;MACY,IAAIrB,YAAJ,EAAkB;QACdC,cAAc,GAAG,IAAjB;QACA;MACH;;MACDD,YAAY,GAAG,IAAf;MAXoB,WAYK,CAACD,SAAD,EAAYF,SAAZ,CAZL;MAYnBA,SAZmB;MAYRE,SAZQ;MAapB;MACAF,SAAS,CAACyB,OAAV,CAAkBd,eAAlB;MACA;AACZ;AACA;;MACY,IAAIZ,QAAQ,IAAIH,WAAW,CAAC8B,KAA5B,EAAmC;QAC/B9B,WAAW,CAAC8B,KAAZ,CAAkBC,SAAlB,CAA4B5B,QAA5B,EAAsC6B,IAAtC,CAA2ClB,QAA3C;MACH;;MACDA,QAAQ,GAAG,CAAX,CArBoB,CAsBpB;MACA;;MACAV,SAAS,CAAC6B,KAAV;MACA1B,YAAY,GAAG,KAAf;;MACA,IAAIC,cAAJ,EAAoB;QAChBA,cAAc,GAAG,KAAjB;QACAU,IAAI,CAACS,OAAL,CAAaC,SAAb;MACH;IACJ;EArDQ,CAAb;EAuDA,OAAOV,IAAP;AACH;;AAED,SAASjB,gBAAT"},"metadata":{},"sourceType":"module"}