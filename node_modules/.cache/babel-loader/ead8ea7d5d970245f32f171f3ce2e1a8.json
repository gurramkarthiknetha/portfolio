{"ast":null,"code":"\"use client\";\n\nimport _createForOfIteratorHelper from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { jsx } from 'react/jsx-runtime';\nimport * as React from 'react';\nimport { useId, useCallback, useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { PopChild } from './PopChild.mjs';\n\nvar PresenceChild = function PresenceChild(_ref) {\n  var children = _ref.children,\n      initial = _ref.initial,\n      isPresent = _ref.isPresent,\n      onExitComplete = _ref.onExitComplete,\n      custom = _ref.custom,\n      presenceAffectsLayout = _ref.presenceAffectsLayout,\n      mode = _ref.mode,\n      anchorX = _ref.anchorX;\n  var presenceChildren = useConstant(newChildrenMap);\n  var id = useId();\n  var memoizedOnExitComplete = useCallback(function (childId) {\n    presenceChildren.set(childId, true);\n\n    var _iterator = _createForOfIteratorHelper(presenceChildren.values()),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var isComplete = _step.value;\n        if (!isComplete) return; // can stop searching when any is incomplete\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    onExitComplete && onExitComplete();\n  }, [presenceChildren, onExitComplete]);\n  var context = useMemo(function () {\n    return {\n      id: id,\n      initial: initial,\n      isPresent: isPresent,\n      custom: custom,\n      onExitComplete: memoizedOnExitComplete,\n      register: function register(childId) {\n        presenceChildren.set(childId, false);\n        return function () {\n          return presenceChildren.delete(childId);\n        };\n      }\n    };\n  },\n  /**\n   * If the presence of a child affects the layout of the components around it,\n   * we want to make a new context value to ensure they get re-rendered\n   * so they can detect that layout change.\n   */\n  presenceAffectsLayout ? [Math.random(), memoizedOnExitComplete] : [isPresent, memoizedOnExitComplete]);\n  useMemo(function () {\n    presenceChildren.forEach(function (_, key) {\n      return presenceChildren.set(key, false);\n    });\n  }, [isPresent]);\n  /**\n   * If there's no `motion` components to fire exit animations, we want to remove this\n   * component immediately.\n   */\n\n  React.useEffect(function () {\n    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();\n  }, [isPresent]);\n\n  if (mode === \"popLayout\") {\n    children = jsx(PopChild, {\n      isPresent: isPresent,\n      anchorX: anchorX,\n      children: children\n    });\n  }\n\n  return jsx(PresenceContext.Provider, {\n    value: context,\n    children: children\n  });\n};\n\nfunction newChildrenMap() {\n  return new Map();\n}\n\nexport { PresenceChild };","map":{"version":3,"names":["jsx","React","useId","useCallback","useMemo","PresenceContext","useConstant","PopChild","PresenceChild","children","initial","isPresent","onExitComplete","custom","presenceAffectsLayout","mode","anchorX","presenceChildren","newChildrenMap","id","memoizedOnExitComplete","childId","set","values","isComplete","context","register","delete","Math","random","forEach","_","key","useEffect","size","Provider","value","Map"],"sources":["/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs"],"sourcesContent":["\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport * as React from 'react';\nimport { useId, useCallback, useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { PopChild } from './PopChild.mjs';\n\nconst PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, }) => {\n    const presenceChildren = useConstant(newChildrenMap);\n    const id = useId();\n    const memoizedOnExitComplete = useCallback((childId) => {\n        presenceChildren.set(childId, true);\n        for (const isComplete of presenceChildren.values()) {\n            if (!isComplete)\n                return; // can stop searching when any is incomplete\n        }\n        onExitComplete && onExitComplete();\n    }, [presenceChildren, onExitComplete]);\n    const context = useMemo(() => ({\n        id,\n        initial,\n        isPresent,\n        custom,\n        onExitComplete: memoizedOnExitComplete,\n        register: (childId) => {\n            presenceChildren.set(childId, false);\n            return () => presenceChildren.delete(childId);\n        },\n    }), \n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    presenceAffectsLayout\n        ? [Math.random(), memoizedOnExitComplete]\n        : [isPresent, memoizedOnExitComplete]);\n    useMemo(() => {\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));\n    }, [isPresent]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(() => {\n        !isPresent &&\n            !presenceChildren.size &&\n            onExitComplete &&\n            onExitComplete();\n    }, [isPresent]);\n    if (mode === \"popLayout\") {\n        children = (jsx(PopChild, { isPresent: isPresent, anchorX: anchorX, children: children }));\n    }\n    return (jsx(PresenceContext.Provider, { value: context, children: children }));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nexport { PresenceChild };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}