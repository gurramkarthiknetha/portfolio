{"ast":null,"code":"import _objectSpread from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { capturePointer, isPrimaryPointer } from 'motion-dom';\nimport { secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { distance2D } from '../../utils/distance.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { frame, cancelFrame, frameData } from '../../frameloop/frame.mjs';\n/**\n * @internal\n */\n\nvar PanSession = /*#__PURE__*/function () {\n  function PanSession(event, handlers) {\n    var _this = this;\n\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        transformPagePoint = _ref.transformPagePoint,\n        _ref$dragSnapToOrigin = _ref.dragSnapToOrigin,\n        dragSnapToOrigin = _ref$dragSnapToOrigin === void 0 ? false : _ref$dragSnapToOrigin;\n\n    _classCallCheck(this, PanSession);\n\n    /**\n     * @internal\n     */\n    this.startEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEventInfo = null;\n    /**\n     * @internal\n     */\n\n    this.handlers = {};\n\n    this.updatePoint = function () {\n      if (!(_this.lastMoveEvent && _this.lastMoveEventInfo)) return;\n      var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n      var isPanStarted = _this.startEvent !== null; // Only start panning if the offset is larger than 3 pixels. If we make it\n      // any larger than this we'll want to reset the pointer history\n      // on the first update to avoid visual snapping to the cursoe.\n\n      var isDistancePastThreshold = distance2D(info.offset, {\n        x: 0,\n        y: 0\n      }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      var point = info.point;\n      var timestamp = frameData.timestamp;\n\n      _this.history.push(_objectSpread(_objectSpread({}, point), {}, {\n        timestamp: timestamp\n      }));\n\n      var _this$handlers = _this.handlers,\n          onStart = _this$handlers.onStart,\n          onMove = _this$handlers.onMove;\n\n      if (!isPanStarted) {\n        onStart && onStart(_this.lastMoveEvent, info);\n        _this.startEvent = _this.lastMoveEvent;\n      }\n\n      onMove && onMove(_this.lastMoveEvent, info);\n    };\n\n    this.handlePointerMove = function (event, info) {\n      if (event.target instanceof Element && event.target.hasPointerCapture && event.pointerId !== undefined) {\n        try {\n          if (!event.target.hasPointerCapture(event.pointerId)) {\n            return;\n          }\n        } catch (e) {}\n      }\n\n      _this.lastMoveEvent = event;\n      _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint); // Throttle mouse move event to once per frame\n\n      frame.update(_this.updatePoint, true);\n    };\n\n    this.handlePointerUp = function (event, info) {\n      capturePointer(event, \"release\");\n\n      _this.end();\n\n      var _this$handlers2 = _this.handlers,\n          onEnd = _this$handlers2.onEnd,\n          onSessionEnd = _this$handlers2.onSessionEnd,\n          resumeAnimation = _this$handlers2.resumeAnimation;\n      if (_this.dragSnapToOrigin) resumeAnimation && resumeAnimation();\n      if (!(_this.lastMoveEvent && _this.lastMoveEventInfo)) return;\n      var panInfo = getPanInfo(event.type === \"pointercancel\" || event.type === \"lostpointercapture\" ? _this.lastMoveEventInfo : transformPoint(info, _this.transformPagePoint), _this.history);\n\n      if (_this.startEvent && onEnd) {\n        onEnd(event, panInfo);\n      }\n\n      onSessionEnd && onSessionEnd(event, panInfo);\n    }; // If we have more than one touch, don't start detecting this gesture\n\n\n    if (!isPrimaryPointer(event)) return;\n    this.dragSnapToOrigin = dragSnapToOrigin;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    var info = extractEventInfo(event);\n    var initialInfo = transformPoint(info, this.transformPagePoint);\n    var point = initialInfo.point;\n    var timestamp = frameData.timestamp;\n    this.history = [_objectSpread(_objectSpread({}, point), {}, {\n      timestamp: timestamp\n    })];\n    var onSessionStart = handlers.onSessionStart;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    capturePointer(event, \"set\");\n    this.removeListeners = pipe(addPointerEvent(event.currentTarget, \"pointermove\", this.handlePointerMove), addPointerEvent(event.currentTarget, \"pointerup\", this.handlePointerUp), addPointerEvent(event.currentTarget, \"pointercancel\", this.handlePointerUp), addPointerEvent(event.currentTarget, \"lostpointercapture\", this.handlePointerUp));\n  }\n\n  _createClass(PanSession, [{\n    key: \"updateHandlers\",\n    value: function updateHandlers(handlers) {\n      this.handlers = handlers;\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      this.removeListeners && this.removeListeners();\n      cancelFrame(this.updatePoint);\n    }\n  }]);\n\n  return PanSession;\n}();\n\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? {\n    point: transformPagePoint(info.point)\n  } : info;\n}\n\nfunction subtractPoint(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\n\nfunction getPanInfo(_ref2, history) {\n  var point = _ref2.point;\n  return {\n    point: point,\n    delta: subtractPoint(point, lastDevicePoint(history)),\n    offset: subtractPoint(point, startDevicePoint(history)),\n    velocity: getVelocity(history, 0.1)\n  };\n}\n\nfunction startDevicePoint(history) {\n  return history[0];\n}\n\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\n\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var i = history.length - 1;\n  var timestampedPoint = null;\n  var lastPoint = lastDevicePoint(history);\n\n  while (i >= 0) {\n    timestampedPoint = history[i];\n\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n\n    i--;\n  }\n\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n\n  return currentVelocity;\n}\n\nexport { PanSession };","map":{"version":3,"names":["capturePointer","isPrimaryPointer","secondsToMilliseconds","millisecondsToSeconds","addPointerEvent","extractEventInfo","distance2D","pipe","frame","cancelFrame","frameData","PanSession","event","handlers","transformPagePoint","dragSnapToOrigin","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","offset","x","y","point","timestamp","push","onStart","onMove","handlePointerMove","target","Element","hasPointerCapture","pointerId","undefined","e","transformPoint","update","handlePointerUp","end","onEnd","onSessionEnd","resumeAnimation","panInfo","type","initialInfo","onSessionStart","removeListeners","currentTarget","subtractPoint","a","b","delta","lastDevicePoint","startDevicePoint","velocity","getVelocity","length","timeDelta","i","timestampedPoint","lastPoint","time","currentVelocity","Infinity"],"sources":["/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs"],"sourcesContent":["import { capturePointer, isPrimaryPointer } from 'motion-dom';\nimport { secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { distance2D } from '../../utils/distance.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { frame, cancelFrame, frameData } from '../../frameloop/frame.mjs';\n\n/**\n * @internal\n */\nclass PanSession {\n    constructor(event, handlers, { transformPagePoint, dragSnapToOrigin = false } = {}) {\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        this.updatePoint = () => {\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\n            const isPanStarted = this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            const { point } = info;\n            const { timestamp } = frameData;\n            this.history.push({ ...point, timestamp });\n            const { onStart, onMove } = this.handlers;\n            if (!isPanStarted) {\n                onStart && onStart(this.lastMoveEvent, info);\n                this.startEvent = this.lastMoveEvent;\n            }\n            onMove && onMove(this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = (event, info) => {\n            if (event.target instanceof Element &&\n                event.target.hasPointerCapture &&\n                event.pointerId !== undefined) {\n                try {\n                    if (!event.target.hasPointerCapture(event.pointerId)) {\n                        return;\n                    }\n                }\n                catch (e) { }\n            }\n            this.lastMoveEvent = event;\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n            // Throttle mouse move event to once per frame\n            frame.update(this.updatePoint, true);\n        };\n        this.handlePointerUp = (event, info) => {\n            capturePointer(event, \"release\");\n            this.end();\n            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\n            if (this.dragSnapToOrigin)\n                resumeAnimation && resumeAnimation();\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const panInfo = getPanInfo(event.type === \"pointercancel\" ||\n                event.type === \"lostpointercapture\"\n                ? this.lastMoveEventInfo\n                : transformPoint(info, this.transformPagePoint), this.history);\n            if (this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (!isPrimaryPointer(event))\n            return;\n        this.dragSnapToOrigin = dragSnapToOrigin;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        const info = extractEventInfo(event);\n        const initialInfo = transformPoint(info, this.transformPagePoint);\n        const { point } = initialInfo;\n        const { timestamp } = frameData;\n        this.history = [{ ...point, timestamp }];\n        const { onSessionStart } = handlers;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        capturePointer(event, \"set\");\n        this.removeListeners = pipe(addPointerEvent(event.currentTarget, \"pointermove\", this.handlePointerMove), addPointerEvent(event.currentTarget, \"pointerup\", this.handlePointerUp), addPointerEvent(event.currentTarget, \"pointercancel\", this.handlePointerUp), addPointerEvent(event.currentTarget, \"lostpointercapture\", this.handlePointerUp));\n    }\n    updateHandlers(handlers) {\n        this.handlers = handlers;\n    }\n    end() {\n        this.removeListeners && this.removeListeners();\n        cancelFrame(this.updatePoint);\n    }\n}\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo({ point }, history) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    let i = history.length - 1;\n    let timestampedPoint = null;\n    const lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nexport { PanSession };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}