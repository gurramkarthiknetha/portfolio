{"ast":null,"code":"import _toConsumableArray from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"defaultTransition\"],\n    _excluded2 = [\"delay\", \"times\", \"type\", \"repeat\", \"repeatType\", \"repeatDelay\"];\nimport { isGenerator, createGeneratorEasing } from 'motion-dom';\nimport { progress, secondsToMilliseconds, invariant } from 'motion-utils';\nimport { getEasingForSegment } from '../../easing/utils/get-easing-for-segment.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { fillOffset } from '../../utils/offsets/fill.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { resolveSubjects } from '../animate/resolve-subjects.mjs';\nimport { calculateRepeatDuration } from './utils/calc-repeat-duration.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { normalizeTimes } from './utils/normalize-times.mjs';\nimport { compareByTime } from './utils/sort.mjs';\nvar defaultSegmentEasing = \"easeInOut\";\nvar MAX_REPEAT = 20;\n\nfunction createAnimationsFromSequence(sequence) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$defaultTransitio = _ref.defaultTransition,\n      defaultTransition = _ref$defaultTransitio === void 0 ? {} : _ref$defaultTransitio,\n      sequenceTransition = _objectWithoutProperties(_ref, _excluded);\n\n  var scope = arguments.length > 2 ? arguments[2] : undefined;\n  var generators = arguments.length > 3 ? arguments[3] : undefined;\n  var defaultDuration = defaultTransition.duration || 0.3;\n  var animationDefinitions = new Map();\n  var sequences = new Map();\n  var elementCache = {};\n  var timeLabels = new Map();\n  var prevTime = 0;\n  var currentTime = 0;\n  var totalDuration = 0;\n  /**\n   * Build the timeline by mapping over the sequence array and converting\n   * the definitions into keyframes and offsets with absolute time values.\n   * These will later get converted into relative offsets in a second pass.\n   */\n\n  var _loop = function _loop(i) {\n    var segment = sequence[i];\n    /**\n     * If this is a timeline label, mark it and skip the rest of this iteration.\n     */\n\n    if (typeof segment === \"string\") {\n      timeLabels.set(segment, currentTime);\n      return \"continue\";\n    } else if (!Array.isArray(segment)) {\n      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n      return \"continue\";\n    }\n\n    var _segment = _slicedToArray(segment, 3),\n        subject = _segment[0],\n        keyframes = _segment[1],\n        _segment$ = _segment[2],\n        transition = _segment$ === void 0 ? {} : _segment$;\n    /**\n     * If a relative or absolute time value has been specified we need to resolve\n     * it in relation to the currentTime.\n     */\n\n\n    if (transition.at !== undefined) {\n      currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n    }\n    /**\n     * Keep track of the maximum duration in this definition. This will be\n     * applied to currentTime once the definition has been parsed.\n     */\n\n\n    var maxDuration = 0;\n\n    var resolveValueSequence = function resolveValueSequence(valueKeyframes, valueTransition, valueSequence) {\n      var elementIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var numSubjects = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var valueKeyframesAsList = keyframesAsList(valueKeyframes);\n\n      var _valueTransition$dela = valueTransition.delay,\n          delay = _valueTransition$dela === void 0 ? 0 : _valueTransition$dela,\n          _valueTransition$time = valueTransition.times,\n          times = _valueTransition$time === void 0 ? defaultOffset(valueKeyframesAsList) : _valueTransition$time,\n          _valueTransition$type = valueTransition.type,\n          type = _valueTransition$type === void 0 ? \"keyframes\" : _valueTransition$type,\n          repeat = valueTransition.repeat,\n          repeatType = valueTransition.repeatType,\n          _valueTransition$repe = valueTransition.repeatDelay,\n          repeatDelay = _valueTransition$repe === void 0 ? 0 : _valueTransition$repe,\n          remainingTransition = _objectWithoutProperties(valueTransition, _excluded2);\n\n      var _valueTransition$ease = valueTransition.ease,\n          ease = _valueTransition$ease === void 0 ? defaultTransition.ease || \"easeOut\" : _valueTransition$ease,\n          duration = valueTransition.duration;\n      /**\n       * Resolve stagger() if defined.\n       */\n\n      var calculatedDelay = typeof delay === \"function\" ? delay(elementIndex, numSubjects) : delay;\n      /**\n       * If this animation should and can use a spring, generate a spring easing function.\n       */\n\n      var numKeyframes = valueKeyframesAsList.length;\n      var createGenerator = isGenerator(type) ? type : generators === null || generators === void 0 ? void 0 : generators[type];\n\n      if (numKeyframes <= 2 && createGenerator) {\n        /**\n         * As we're creating an easing function from a spring,\n         * ideally we want to generate it using the real distance\n         * between the two keyframes. However this isn't always\n         * possible - in these situations we use 0-100.\n         */\n        var absoluteDelta = 100;\n\n        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {\n          var delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n          absoluteDelta = Math.abs(delta);\n        }\n\n        var springTransition = _objectSpread({}, remainingTransition);\n\n        if (duration !== undefined) {\n          springTransition.duration = secondsToMilliseconds(duration);\n        }\n\n        var springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);\n        ease = springEasing.ease;\n        duration = springEasing.duration;\n      }\n\n      duration !== null && duration !== void 0 ? duration : duration = defaultDuration;\n      var startTime = currentTime + calculatedDelay;\n      /**\n       * If there's only one time offset of 0, fill in a second with length 1\n       */\n\n      if (times.length === 1 && times[0] === 0) {\n        times[1] = 1;\n      }\n      /**\n       * Fill out if offset if fewer offsets than keyframes\n       */\n\n\n      var remainder = times.length - valueKeyframesAsList.length;\n      remainder > 0 && fillOffset(times, remainder);\n      /**\n       * If only one value has been set, ie [1], push a null to the start of\n       * the keyframe array. This will let us mark a keyframe at this point\n       * that will later be hydrated with the previous value.\n       */\n\n      valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);\n      /**\n       * Handle repeat options\n       */\n\n      if (repeat) {\n        invariant(repeat < MAX_REPEAT, \"Repeat count too high, must be less than 20\");\n        duration = calculateRepeatDuration(duration, repeat);\n\n        var originalKeyframes = _toConsumableArray(valueKeyframesAsList);\n\n        var originalTimes = _toConsumableArray(times);\n\n        ease = Array.isArray(ease) ? _toConsumableArray(ease) : [ease];\n\n        var originalEase = _toConsumableArray(ease);\n\n        for (var repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {\n          valueKeyframesAsList.push.apply(valueKeyframesAsList, _toConsumableArray(originalKeyframes));\n\n          for (var keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {\n            times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));\n            ease.push(keyframeIndex === 0 ? \"linear\" : getEasingForSegment(originalEase, keyframeIndex - 1));\n          }\n        }\n\n        normalizeTimes(times, repeat);\n      }\n\n      var targetTime = startTime + duration;\n      /**\n       * Add keyframes, mapping offsets to absolute time.\n       */\n\n      addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n      maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n      totalDuration = Math.max(targetTime, totalDuration);\n    };\n\n    if (isMotionValue(subject)) {\n      var subjectSequence = getSubjectSequence(subject, sequences);\n      resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n    } else {\n      var subjects = resolveSubjects(subject, keyframes, scope, elementCache);\n      var numSubjects = subjects.length;\n      /**\n       * For every element in this segment, process the defined values.\n       */\n\n      for (var subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {\n        /**\n         * Cast necessary, but we know these are of this type\n         */\n        keyframes = keyframes;\n        transition = transition;\n        var thisSubject = subjects[subjectIndex];\n\n        var _subjectSequence = getSubjectSequence(thisSubject, sequences);\n\n        for (var key in keyframes) {\n          resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, _subjectSequence), subjectIndex, numSubjects);\n        }\n      }\n    }\n\n    prevTime = currentTime;\n    currentTime += maxDuration;\n  };\n\n  for (var i = 0; i < sequence.length; i++) {\n    var _ret = _loop(i);\n\n    if (_ret === \"continue\") continue;\n  }\n  /**\n   * For every element and value combination create a new animation.\n   */\n\n\n  sequences.forEach(function (valueSequences, element) {\n    for (var key in valueSequences) {\n      var valueSequence = valueSequences[key];\n      /**\n       * Arrange all the keyframes in ascending time order.\n       */\n\n      valueSequence.sort(compareByTime);\n      var keyframes = [];\n      var valueOffset = [];\n      var valueEasing = [];\n      /**\n       * For each keyframe, translate absolute times into\n       * relative offsets based on the total duration of the timeline.\n       */\n\n      for (var _i = 0; _i < valueSequence.length; _i++) {\n        var _valueSequence$_i = valueSequence[_i],\n            at = _valueSequence$_i.at,\n            value = _valueSequence$_i.value,\n            easing = _valueSequence$_i.easing;\n        keyframes.push(value);\n        valueOffset.push(progress(0, totalDuration, at));\n        valueEasing.push(easing || \"easeOut\");\n      }\n      /**\n       * If the first keyframe doesn't land on offset: 0\n       * provide one by duplicating the initial keyframe. This ensures\n       * it snaps to the first keyframe when the animation starts.\n       */\n\n\n      if (valueOffset[0] !== 0) {\n        valueOffset.unshift(0);\n        keyframes.unshift(keyframes[0]);\n        valueEasing.unshift(defaultSegmentEasing);\n      }\n      /**\n       * If the last keyframe doesn't land on offset: 1\n       * provide one with a null wildcard value. This will ensure it\n       * stays static until the end of the animation.\n       */\n\n\n      if (valueOffset[valueOffset.length - 1] !== 1) {\n        valueOffset.push(1);\n        keyframes.push(null);\n      }\n\n      if (!animationDefinitions.has(element)) {\n        animationDefinitions.set(element, {\n          keyframes: {},\n          transition: {}\n        });\n      }\n\n      var definition = animationDefinitions.get(element);\n      definition.keyframes[key] = keyframes;\n      definition.transition[key] = _objectSpread(_objectSpread({}, defaultTransition), {}, {\n        duration: totalDuration,\n        ease: valueEasing,\n        times: valueOffset\n      }, sequenceTransition);\n    }\n  });\n  return animationDefinitions;\n}\n\nfunction getSubjectSequence(subject, sequences) {\n  !sequences.has(subject) && sequences.set(subject, {});\n  return sequences.get(subject);\n}\n\nfunction getValueSequence(name, sequences) {\n  if (!sequences[name]) sequences[name] = [];\n  return sequences[name];\n}\n\nfunction keyframesAsList(keyframes) {\n  return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\n\nfunction getValueTransition(transition, key) {\n  return transition && transition[key] ? _objectSpread(_objectSpread({}, transition), transition[key]) : _objectSpread({}, transition);\n}\n\nvar isNumber = function isNumber(keyframe) {\n  return typeof keyframe === \"number\";\n};\n\nvar isNumberKeyframesArray = function isNumberKeyframesArray(keyframes) {\n  return keyframes.every(isNumber);\n};\n\nexport { createAnimationsFromSequence, getValueTransition };","map":{"version":3,"names":["isGenerator","createGeneratorEasing","progress","secondsToMilliseconds","invariant","getEasingForSegment","defaultOffset","fillOffset","isMotionValue","resolveSubjects","calculateRepeatDuration","calcNextTime","addKeyframes","normalizeTimes","compareByTime","defaultSegmentEasing","MAX_REPEAT","createAnimationsFromSequence","sequence","defaultTransition","sequenceTransition","scope","generators","defaultDuration","duration","animationDefinitions","Map","sequences","elementCache","timeLabels","prevTime","currentTime","totalDuration","i","segment","set","Array","isArray","name","at","subject","keyframes","transition","undefined","maxDuration","resolveValueSequence","valueKeyframes","valueTransition","valueSequence","elementIndex","numSubjects","valueKeyframesAsList","keyframesAsList","delay","times","type","repeat","repeatType","repeatDelay","remainingTransition","ease","calculatedDelay","numKeyframes","length","createGenerator","absoluteDelta","isNumberKeyframesArray","delta","Math","abs","springTransition","springEasing","startTime","remainder","unshift","originalKeyframes","originalTimes","originalEase","repeatIndex","push","keyframeIndex","targetTime","max","subjectSequence","getSubjectSequence","getValueSequence","subjects","subjectIndex","thisSubject","key","getValueTransition","forEach","valueSequences","element","sort","valueOffset","valueEasing","value","easing","has","definition","get","isNumber","keyframe","every"],"sources":["/Users/karthikgurram/Public/portfolio/web-dev-projects/personal-portfolio/node_modules/framer-motion/dist/es/animation/sequence/create.mjs"],"sourcesContent":["import { isGenerator, createGeneratorEasing } from 'motion-dom';\nimport { progress, secondsToMilliseconds, invariant } from 'motion-utils';\nimport { getEasingForSegment } from '../../easing/utils/get-easing-for-segment.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { fillOffset } from '../../utils/offsets/fill.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { resolveSubjects } from '../animate/resolve-subjects.mjs';\nimport { calculateRepeatDuration } from './utils/calc-repeat-duration.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { normalizeTimes } from './utils/normalize-times.mjs';\nimport { compareByTime } from './utils/sort.mjs';\n\nconst defaultSegmentEasing = \"easeInOut\";\nconst MAX_REPEAT = 20;\nfunction createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {\n    const defaultDuration = defaultTransition.duration || 0.3;\n    const animationDefinitions = new Map();\n    const sequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        let [subject, keyframes, transition = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n            const { delay = 0, times = defaultOffset(valueKeyframesAsList), type = \"keyframes\", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;\n            let { ease = defaultTransition.ease || \"easeOut\", duration } = valueTransition;\n            /**\n             * Resolve stagger() if defined.\n             */\n            const calculatedDelay = typeof delay === \"function\"\n                ? delay(elementIndex, numSubjects)\n                : delay;\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */\n            const numKeyframes = valueKeyframesAsList.length;\n            const createGenerator = isGenerator(type)\n                ? type\n                : generators === null || generators === void 0 ? void 0 : generators[type];\n            if (numKeyframes <= 2 && createGenerator) {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */\n                let absoluteDelta = 100;\n                if (numKeyframes === 2 &&\n                    isNumberKeyframesArray(valueKeyframesAsList)) {\n                    const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n                    absoluteDelta = Math.abs(delta);\n                }\n                const springTransition = { ...remainingTransition };\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration);\n                }\n                const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);\n                ease = springEasing.ease;\n                duration = springEasing.duration;\n            }\n            duration !== null && duration !== void 0 ? duration : (duration = defaultDuration);\n            const startTime = currentTime + calculatedDelay;\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1;\n            }\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length;\n            remainder > 0 && fillOffset(times, remainder);\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null);\n            /**\n             * Handle repeat options\n             */\n            if (repeat) {\n                invariant(repeat < MAX_REPEAT, \"Repeat count too high, must be less than 20\");\n                duration = calculateRepeatDuration(duration, repeat);\n                const originalKeyframes = [...valueKeyframesAsList];\n                const originalTimes = [...times];\n                ease = Array.isArray(ease) ? [...ease] : [ease];\n                const originalEase = [...ease];\n                for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {\n                    valueKeyframesAsList.push(...originalKeyframes);\n                    for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {\n                        times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));\n                        ease.push(keyframeIndex === 0\n                            ? \"linear\"\n                            : getEasingForSegment(originalEase, keyframeIndex - 1));\n                    }\n                }\n                normalizeTimes(times, repeat);\n            }\n            const targetTime = startTime + duration;\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n            totalDuration = Math.max(targetTime, totalDuration);\n        };\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences);\n            resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n        }\n        else {\n            const subjects = resolveSubjects(subject, keyframes, scope, elementCache);\n            const numSubjects = subjects.length;\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes;\n                transition = transition;\n                const thisSubject = subjects[subjectIndex];\n                const subjectSequence = getSubjectSequence(thisSubject, sequences);\n                for (const key in keyframes) {\n                    resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);\n                }\n            }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || \"easeOut\");\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(defaultSegmentEasing);\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                });\n            }\n            const definition = animationDefinitions.get(element);\n            definition.keyframes[key] = keyframes;\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            };\n        }\n    });\n    return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n    !sequences.has(subject) && sequences.set(subject, {});\n    return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n    return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n    return transition && transition[key]\n        ? {\n            ...transition,\n            ...transition[key],\n        }\n        : { ...transition };\n}\nconst isNumber = (keyframe) => typeof keyframe === \"number\";\nconst isNumberKeyframesArray = (keyframes) => keyframes.every(isNumber);\n\nexport { createAnimationsFromSequence, getValueTransition };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}